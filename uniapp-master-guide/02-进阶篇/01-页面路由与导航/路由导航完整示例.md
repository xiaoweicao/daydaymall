# UniApp 页面路由与导航

## 1. 路由跳转方式

### 1.1 uni.navigateTo - 保留当前页面

保留当前页面，跳转到应用内的某个页面，使用 `uni.navigateBack` 可以返回到原页面。

```typescript
// 基础跳转
uni.navigateTo({
  url: '/pages/detail/detail'
})

// 携带参数
uni.navigateTo({
  url: '/pages/detail/detail?id=123&name=product',
  success: () => {
    console.log('跳转成功')
  },
  fail: (err) => {
    console.error('跳转失败', err)
  }
})

// 传递对象参数（需序列化）
const params = {
  id: 123,
  name: 'product',
  info: { price: 99, stock: 100 }
}
uni.navigateTo({
  url: `/pages/detail/detail?data=${encodeURIComponent(JSON.stringify(params))}`
})
```

### 1.2 uni.redirectTo - 关闭当前页面

关闭当前页面，跳转到应用内的某个页面。

```typescript
uni.redirectTo({
  url: '/pages/login/login'
})

// 适用场景：登录成功后跳转到首页
const handleLogin = () => {
  // 登录逻辑...
  uni.redirectTo({
    url: '/pages/index/index'
  })
}
```

### 1.3 uni.reLaunch - 关闭所有页面

关闭所有页面，打开到应用内的某个页面。

```typescript
// 重新加载应用
uni.reLaunch({
  url: '/pages/index/index'
})

// 适用场景：切换账号、退出登录
const logout = () => {
  // 清除登录信息
  uni.removeStorageSync('token')
  
  // 重新加载到登录页
  uni.reLaunch({
    url: '/pages/login/login'
  })
}
```

### 1.4 uni.switchTab - 切换 Tab 页面

跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面。

```typescript
// 跳转到首页（tabBar 页面）
uni.switchTab({
  url: '/pages/index/index'
})

// 注意：tabBar 页面不能携带参数
// ❌ 错误示例
uni.switchTab({
  url: '/pages/index/index?id=123' // 参数会被忽略
})
```

### 1.5 uni.navigateBack - 返回上一页

关闭当前页面，返回上一页面或多级页面。

```typescript
// 返回上一页
uni.navigateBack()

// 返回多级页面
uni.navigateBack({
  delta: 2 // 返回2层
})

// 带参数返回（通过事件通信）
uni.navigateBack({
  success: () => {
    // 通过 eventChannel 或 getCurrentPages 传递数据
    const pages = getCurrentPages()
    const prevPage = pages[pages.length - 2]
    prevPage.$vm.loadData() // 调用上一页的方法
  }
})
```

## 2. 页面参数传递

### 2.1 URL 参数传递

**发送页面：**
```vue
<template>
  <button @click="goToDetail">查看详情</button>
</template>

<script setup lang="ts">
const productId = ref(123)

const goToDetail = () => {
  uni.navigateTo({
    url: `/pages/detail/detail?id=${productId.value}&from=list`
  })
}
</script>
```

**接收页面：**
```vue
<script setup lang="ts">
import { ref } from 'vue'
import { onLoad } from '@dcloudio/uni-app'

const productId = ref('')
const from = ref('')

onLoad((options) => {
  productId.value = options.id || ''
  from.value = options.from || ''
  
  console.log('接收到的参数：', options)
  
  // 加载数据
  loadProductDetail(productId.value)
})

const loadProductDetail = (id: string) => {
  // 请求详情数据
}
</script>
```

### 2.2 传递复杂对象

```typescript
// 发送页面
const product = {
  id: 123,
  name: '商品名称',
  price: 99.9,
  specs: ['红色', '大号']
}

uni.navigateTo({
  url: `/pages/detail/detail?data=${encodeURIComponent(JSON.stringify(product))}`
})

// 接收页面
onLoad((options) => {
  if (options.data) {
    const product = JSON.parse(decodeURIComponent(options.data))
    console.log('商品信息：', product)
  }
})
```

### 2.3 使用 EventChannel（推荐）

```typescript
// 发送页面
uni.navigateTo({
  url: '/pages/detail/detail',
  success: (res) => {
    // 通过 eventChannel 传递数据
    res.eventChannel.emit('acceptData', {
      id: 123,
      name: '商品名称',
      data: { /* 复杂数据 */ }
    })
  }
})

// 接收页面
onLoad(() => {
  const eventChannel = this.getOpenerEventChannel()
  
  eventChannel.on('acceptData', (data) => {
    console.log('接收到的数据：', data)
  })
})
```

### 2.4 页面返回传参

```typescript
// 详情页返回并传递数据给列表页
const backToList = () => {
  const pages = getCurrentPages()
  const prevPage = pages[pages.length - 2]
  
  // 调用上一页的方法
  if (prevPage) {
    prevPage.$vm.updateData({
      id: 123,
      status: 'updated'
    })
  }
  
  uni.navigateBack()
}

// 列表页接收数据
const updateData = (data: any) => {
  console.log('接收到返回的数据：', data)
  // 更新列表
  refreshList()
}
</script>
```

## 3. 路由守卫实现

UniApp 没有内置路由守卫，但可以自己实现：

```typescript
// utils/router.ts
interface RouteConfig {
  url: string
  needLogin?: boolean
}

/**
 * 路由跳转拦截器
 */
export const navigateTo = (config: RouteConfig) => {
  const { url, needLogin = false } = config
  
  // 检查是否需要登录
  if (needLogin) {
    const token = uni.getStorageSync('token')
    if (!token) {
      uni.showToast({
        title: '请先登录',
        icon: 'none'
      })
      
      // 跳转到登录页，并记录来源页面
      uni.navigateTo({
        url: `/pages/login/login?redirect=${encodeURIComponent(url)}`
      })
      return
    }
  }
  
  // 正常跳转
  uni.navigateTo({ url })
}

/**
 * 重定向跳转
 */
export const redirectTo = (config: RouteConfig) => {
  const { url, needLogin = false } = config
  
  if (needLogin) {
    const token = uni.getStorageSync('token')
    if (!token) {
      uni.redirectTo({
        url: '/pages/login/login'
      })
      return
    }
  }
  
  uni.redirectTo({ url })
}

/**
 * 全局路由配置
 */
export const routes = {
  HOME: '/pages/index/index',
  LOGIN: '/pages/login/login',
  USER: '/pages/user/user',
  ORDER: '/pages/order/order',
  DETAIL: '/pages/detail/detail'
}
```

**使用示例：**
```typescript
import { navigateTo, routes } from '@/utils/router'

// 需要登录的页面
const goToOrder = () => {
  navigateTo({
    url: routes.ORDER,
    needLogin: true
  })
}

// 普通跳转
const goToDetail = (id: number) => {
  navigateTo({
    url: `${routes.DETAIL}?id=${id}`
  })
}
```

## 4. 页面栈管理

### 4.1 获取当前页面栈

```typescript
// 获取所有页面实例
const pages = getCurrentPages()

// 当前页面
const currentPage = pages[pages.length - 1]

// 上一页
const prevPage = pages[pages.length - 2]

console.log('页面栈层级：', pages.length)
console.log('当前页面路由：', currentPage.route)
```

### 4.2 页面栈限制

UniApp 默认最多10层页面栈，超过后 `navigateTo` 会失败。

```typescript
const checkPageStack = () => {
  const pages = getCurrentPages()
  
  if (pages.length >= 10) {
    // 使用 redirectTo 代替 navigateTo
    uni.redirectTo({
      url: '/pages/detail/detail'
    })
  } else {
    uni.navigateTo({
      url: '/pages/detail/detail'
    })
  }
}
```

## 5. 完整示例

### 5.1 商品列表页

```vue
<template>
  <view class="page">
    <view 
      class="product-item" 
      v-for="item in productList" 
      :key="item.id"
      @click="goToDetail(item)"
    >
      <image :src="item.image" />
      <text class="name">{{ item.name }}</text>
      <text class="price">¥{{ item.price }}</text>
    </view>
  </view>
</template>

<script setup lang="ts">
import { ref } from 'vue'
import { onLoad, onShow } from '@dcloudio/uni-app'

interface Product {
  id: number
  name: string
  price: number
  image: string
}

const productList = ref<Product[]>([])

onLoad(() => {
  loadProducts()
})

onShow(() => {
  // 从详情页返回时刷新
  console.log('页面显示，可以在这里刷新数据')
})

const loadProducts = async () => {
  // 模拟数据
  productList.value = [
    { id: 1, name: '商品1', price: 99, image: '/static/1.jpg' },
    { id: 2, name: '商品2', price: 199, image: '/static/2.jpg' }
  ]
}

const goToDetail = (item: Product) => {
  // 方式1：URL 参数
  uni.navigateTo({
    url: `/pages/detail/detail?id=${item.id}`
  })
  
  // 方式2：传递对象（推荐复杂数据）
  // uni.navigateTo({
  //   url: '/pages/detail/detail',
  //   success: (res) => {
  //     res.eventChannel.emit('productData', item)
  //   }
  // })
}

// 供子页面调用的更新方法
const updateProduct = (id: number, data: any) => {
  const index = productList.value.findIndex(item => item.id === id)
  if (index !== -1) {
    productList.value[index] = { ...productList.value[index], ...data }
  }
}
</script>
```

### 5.2 商品详情页

```vue
<template>
  <view class="page">
    <image :src="product.image" />
    <text class="name">{{ product.name }}</text>
    <text class="price">¥{{ product.price }}</text>
    
    <button @click="addToCart">加入购物车</button>
    <button @click="goBack">返回</button>
  </view>
</template>

<script setup lang="ts">
import { ref } from 'vue'
import { onLoad } from '@dcloudio/uni-app'

interface Product {
  id: number
  name: string
  price: number
  image: string
}

const product = ref<Product>({
  id: 0,
  name: '',
  price: 0,
  image: ''
})

onLoad((options) => {
  // 方式1：接收 URL 参数
  if (options.id) {
    loadProductDetail(Number(options.id))
  }
  
  // 方式2：接收 eventChannel 数据
  // const eventChannel = this.getOpenerEventChannel()
  // eventChannel.on('productData', (data) => {
  //   product.value = data
  // })
})

const loadProductDetail = async (id: number) => {
  // 模拟请求
  product.value = {
    id,
    name: `商品${id}`,
    price: 99,
    image: '/static/product.jpg'
  }
}

const addToCart = () => {
  uni.showToast({
    title: '已加入购物车',
    icon: 'success'
  })
}

const goBack = () => {
  // 调用上一页的方法更新数据
  const pages = getCurrentPages()
  const prevPage = pages[pages.length - 2]
  
  if (prevPage) {
    prevPage.$vm.updateProduct(product.value.id, {
      // 更新的数据
    })
  }
  
  uni.navigateBack()
}
</script>
```

## 6. 最佳实践

### 6.1 路由管理

1. **统一路由配置**：将所有路由路径定义为常量
2. **封装跳转方法**：统一处理登录验证、参数序列化等
3. **参数验证**：跳转前验证必要参数

### 6.2 性能优化

1. **合理使用跳转方式**：
   - 需要返回：`navigateTo`
   - 不需要返回：`redirectTo`
   - 清空历史：`reLaunch`

2. **控制页面栈深度**：超过5层考虑使用 `redirectTo`

3. **避免频繁跳转**：添加防抖处理

### 6.3 用户体验

1. **loading 提示**：跳转前显示加载状态
2. **错误处理**：跳转失败时给出友好提示
3. **返回拦截**：重要操作前确认

## 7. 常见问题

### Q1: tabBar 页面如何传参？

A: tabBar 页面不支持 URL 传参，可以使用：
- 全局状态管理（Pinia）
- 本地存储
- EventBus

### Q2: 如何实现页面刷新？

A: 使用 `onShow` 生命周期或 `reLaunch` 重新加载

### Q3: 如何防止重复点击跳转？

A: 添加节流/防抖或 loading 状态

```typescript
let isNavigating = false

const goToDetail = () => {
  if (isNavigating) return
  
  isNavigating = true
  uni.navigateTo({
    url: '/pages/detail/detail',
    complete: () => {
      setTimeout(() => {
        isNavigating = false
      }, 500)
    }
  })
}
```
